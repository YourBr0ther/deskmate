"""
Tests for the Action Executor service.
Tests the execution of actions generated by Brain Council.
"""

import pytest
from unittest.mock import AsyncMock, Mock, patch
import json

from app.services.action_executor import ActionExecutor, ActionResult
from app.services.assistant_service import assistant_service
from app.services.room_service import room_service
from app.services.pathfinding import pathfinding_service


@pytest.fixture
def action_executor():
    """Create an ActionExecutor instance for testing."""
    return ActionExecutor()


@pytest.fixture
def mock_assistant_state():
    """Mock assistant state."""
    return {
        "position": {"x": 32, "y": 8},
        "facing": "right",
        "current_action": "idle",
        "mood": "neutral",
        "expression": "neutral.png",
        "mode": "active",
        "energy": 0.8,
        "holding_object_id": None,
        "sitting_on_object_id": None,
        "status": "idle"
    }


@pytest.fixture
def mock_room_objects():
    """Mock room objects."""
    return [
        {
            "id": "lamp_001",
            "name": "Desk Lamp",
            "position": {"x": 15, "y": 5},
            "size": {"width": 1, "height": 1},
            "type": "item",
            "description": "A bright desk lamp",
            "state": "off",
            "movable": True,
            "interactive": True,
        },
        {
            "id": "bed",
            "name": "Bed",
            "position": {"x": 5, "y": 10},
            "size": {"width": 4, "height": 2},
            "type": "furniture",
            "description": "A comfortable bed",
            "state": "made",
            "movable": False,
            "interactive": True,
        },
    ]


class TestActionExecutorMovement:
    """Test movement action execution."""

    @pytest.mark.asyncio
    async def test_execute_move_action_success(self, action_executor, mock_assistant_state):
        """Test successful movement action execution."""

        move_action = {
            "type": "move",
            "target": {"x": 20, "y": 10},
            "parameters": {"reason": "Moving to new position"}
        }

        mock_path = [
            {"x": 32, "y": 8},
            {"x": 30, "y": 9},
            {"x": 25, "y": 10},
            {"x": 20, "y": 10}
        ]

        with patch.object(assistant_service, 'get_assistant_state', return_value=mock_assistant_state), \
             patch.object(pathfinding_service, 'find_path', return_value=mock_path), \
             patch.object(assistant_service, 'update_assistant_position') as mock_update, \
             patch.object(assistant_service, 'set_assistant_action') as mock_set_action:

            result = await action_executor.execute_action(move_action)

            assert result.success is True
            assert result.action_type == "move"
            assert "moved" in result.message.lower()

            # Verify assistant state was updated
            mock_update.assert_called_with(20, 10)
            mock_set_action.assert_called()

    @pytest.mark.asyncio
    async def test_execute_move_action_no_path(self, action_executor, mock_assistant_state):
        """Test movement action when no path is available."""

        move_action = {
            "type": "move",
            "target": {"x": 20, "y": 10},
            "parameters": {"reason": "Moving to blocked position"}
        }

        with patch.object(assistant_service, 'get_assistant_state', return_value=mock_assistant_state), \
             patch.object(pathfinding_service, 'find_path', return_value=None):

            result = await action_executor.execute_action(move_action)

            assert result.success is False
            assert result.action_type == "move"
            assert "blocked" in result.message.lower() or "path" in result.message.lower()

    @pytest.mark.asyncio
    async def test_execute_move_action_out_of_bounds(self, action_executor, mock_assistant_state):
        """Test movement action to position outside grid bounds."""

        move_action = {
            "type": "move",
            "target": {"x": 100, "y": 100},  # Outside 64x16 grid
            "parameters": {"reason": "Moving outside bounds"}
        }

        with patch.object(assistant_service, 'get_assistant_state', return_value=mock_assistant_state):

            result = await action_executor.execute_action(move_action)

            assert result.success is False
            assert result.action_type == "move"
            assert "bounds" in result.message.lower() or "invalid" in result.message.lower()


class TestActionExecutorObjectInteraction:
    """Test object interaction action execution."""

    @pytest.mark.asyncio
    async def test_execute_interact_action_turn_on_lamp(self, action_executor,
                                                       mock_assistant_state, mock_room_objects):
        """Test turning on a lamp through interaction."""

        interact_action = {
            "type": "interact",
            "target": "lamp_001",
            "parameters": {"action": "turn_on", "reason": "User requested light"}
        }

        with patch.object(assistant_service, 'get_assistant_state', return_value=mock_assistant_state), \
             patch.object(room_service, 'get_object_by_id', return_value=mock_room_objects[0]), \
             patch.object(room_service, 'update_object_state') as mock_update_state, \
             patch.object(assistant_service, 'set_assistant_action') as mock_set_action:

            result = await action_executor.execute_action(interact_action)

            assert result.success is True
            assert result.action_type == "interact"
            assert "lamp" in result.message.lower()
            assert "on" in result.message.lower()

            # Verify object state was updated
            mock_update_state.assert_called_with("lamp_001", "power", "on")

    @pytest.mark.asyncio
    async def test_execute_interact_action_sit_on_furniture(self, action_executor,
                                                           mock_assistant_state, mock_room_objects):
        """Test sitting on furniture."""

        interact_action = {
            "type": "interact",
            "target": "bed",
            "parameters": {"action": "sit", "reason": "User requested sitting"}
        }

        with patch.object(assistant_service, 'get_assistant_state', return_value=mock_assistant_state), \
             patch.object(room_service, 'get_object_by_id', return_value=mock_room_objects[1]), \
             patch.object(assistant_service, 'set_assistant_sitting') as mock_sit, \
             patch.object(assistant_service, 'set_assistant_action') as mock_set_action:

            result = await action_executor.execute_action(interact_action)

            assert result.success is True
            assert result.action_type == "interact"
            assert "sitting" in result.message.lower() or "bed" in result.message.lower()

            # Verify sitting state was set
            mock_sit.assert_called_with("bed")

    @pytest.mark.asyncio
    async def test_execute_interact_action_object_not_found(self, action_executor, mock_assistant_state):
        """Test interaction with non-existent object."""

        interact_action = {
            "type": "interact",
            "target": "nonexistent_object",
            "parameters": {"action": "use", "reason": "Testing error case"}
        }

        with patch.object(assistant_service, 'get_assistant_state', return_value=mock_assistant_state), \
             patch.object(room_service, 'get_object_by_id', return_value=None):

            result = await action_executor.execute_action(interact_action)

            assert result.success is False
            assert result.action_type == "interact"
            assert "not found" in result.message.lower() or "doesn't exist" in result.message.lower()

    @pytest.mark.asyncio
    async def test_execute_interact_action_too_far(self, action_executor, mock_room_objects):
        """Test interaction when assistant is too far from object."""

        # Assistant far from lamp
        distant_assistant = {
            "position": {"x": 50, "y": 1},
            "facing": "right",
            "current_action": "idle",
            "mood": "neutral",
            "status": "idle"
        }

        interact_action = {
            "type": "interact",
            "target": "lamp_001",
            "parameters": {"action": "turn_on", "reason": "Testing distance check"}
        }

        with patch.object(assistant_service, 'get_assistant_state', return_value=distant_assistant), \
             patch.object(room_service, 'get_object_by_id', return_value=mock_room_objects[0]):

            result = await action_executor.execute_action(interact_action)

            assert result.success is False
            assert result.action_type == "interact"
            assert "too far" in result.message.lower() or "reach" in result.message.lower()


class TestActionExecutorStateChanges:
    """Test state change action execution."""

    @pytest.mark.asyncio
    async def test_execute_state_change_action(self, action_executor, mock_assistant_state):
        """Test changing assistant's mood/expression."""

        state_action = {
            "type": "state_change",
            "target": "assistant",
            "parameters": {
                "mood": "happy",
                "expression": "happy.png",
                "reason": "User made me happy"
            }
        }

        with patch.object(assistant_service, 'get_assistant_state', return_value=mock_assistant_state), \
             patch.object(assistant_service, 'set_assistant_mood') as mock_mood, \
             patch.object(assistant_service, 'set_assistant_expression') as mock_expression:

            result = await action_executor.execute_action(state_action)

            assert result.success is True
            assert result.action_type == "state_change"

            # Verify state changes were applied
            mock_mood.assert_called_with("happy")
            mock_expression.assert_called_with("happy.png")

    @pytest.mark.asyncio
    async def test_execute_object_state_change(self, action_executor, mock_assistant_state, mock_room_objects):
        """Test changing object state directly."""

        state_action = {
            "type": "state_change",
            "target": "lamp_001",
            "parameters": {
                "state": "on",
                "color": "blue",
                "reason": "Changing lamp properties"
            }
        }

        with patch.object(assistant_service, 'get_assistant_state', return_value=mock_assistant_state), \
             patch.object(room_service, 'get_object_by_id', return_value=mock_room_objects[0]), \
             patch.object(room_service, 'update_object_state') as mock_update:

            result = await action_executor.execute_action(state_action)

            assert result.success is True
            assert result.action_type == "state_change"

            # Verify object state was updated
            assert mock_update.call_count == 2  # state and color
            mock_update.assert_any_call("lamp_001", "state", "on")
            mock_update.assert_any_call("lamp_001", "color", "blue")


class TestActionExecutorComplexActions:
    """Test complex action sequences and validation."""

    @pytest.mark.asyncio
    async def test_execute_multiple_actions_sequence(self, action_executor, mock_assistant_state, mock_room_objects):
        """Test executing a sequence of actions."""

        actions = [
            {
                "type": "move",
                "target": {"x": 15, "y": 5},
                "parameters": {"reason": "Moving to lamp"}
            },
            {
                "type": "interact",
                "target": "lamp_001",
                "parameters": {"action": "turn_on", "reason": "Turning on light"}
            },
            {
                "type": "state_change",
                "target": "assistant",
                "parameters": {"mood": "satisfied", "reason": "Task completed"}
            }
        ]

        mock_path = [{"x": 32, "y": 8}, {"x": 15, "y": 5}]

        with patch.object(assistant_service, 'get_assistant_state', return_value=mock_assistant_state), \
             patch.object(room_service, 'get_object_by_id', return_value=mock_room_objects[0]), \
             patch.object(pathfinding_service, 'find_path', return_value=mock_path), \
             patch.object(assistant_service, 'update_assistant_position'), \
             patch.object(assistant_service, 'set_assistant_action'), \
             patch.object(room_service, 'update_object_state'), \
             patch.object(assistant_service, 'set_assistant_mood'):

            results = await action_executor.execute_actions(actions)

            assert len(results) == 3
            assert all(result.success for result in results)
            assert results[0].action_type == "move"
            assert results[1].action_type == "interact"
            assert results[2].action_type == "state_change"

    @pytest.mark.asyncio
    async def test_action_validation_prevents_invalid_actions(self, action_executor, mock_assistant_state):
        """Test that action validation prevents invalid actions."""

        invalid_action = {
            "type": "unknown_type",
            "target": "something",
            "parameters": {"reason": "This should fail"}
        }

        with patch.object(assistant_service, 'get_assistant_state', return_value=mock_assistant_state):

            result = await action_executor.execute_action(invalid_action)

            assert result.success is False
            assert "unknown" in result.message.lower() or "invalid" in result.message.lower()

    @pytest.mark.asyncio
    async def test_action_execution_with_energy_consideration(self, action_executor, mock_room_objects):
        """Test that actions consider assistant's energy level."""

        tired_assistant = {
            "position": {"x": 32, "y": 8},
            "energy": 0.1,  # Very low energy
            "status": "tired"
        }

        high_energy_action = {
            "type": "move",
            "target": {"x": 5, "y": 15},  # Far movement
            "parameters": {"reason": "Long distance movement when tired"}
        }

        with patch.object(assistant_service, 'get_assistant_state', return_value=tired_assistant):

            result = await action_executor.execute_action(high_energy_action)

            # Should either succeed with energy cost or warn about tiredness
            if not result.success:
                assert "tired" in result.message.lower() or "energy" in result.message.lower()


class TestActionExecutorErrorHandling:
    """Test error handling in action execution."""

    @pytest.mark.asyncio
    async def test_handles_service_failures_gracefully(self, action_executor, mock_assistant_state):
        """Test graceful handling of service failures."""

        move_action = {
            "type": "move",
            "target": {"x": 20, "y": 10},
            "parameters": {"reason": "Testing error handling"}
        }

        with patch.object(assistant_service, 'get_assistant_state', return_value=mock_assistant_state), \
             patch.object(pathfinding_service, 'find_path', side_effect=Exception("Pathfinding failed")):

            result = await action_executor.execute_action(move_action)

            assert result.success is False
            assert "error" in result.message.lower() or "failed" in result.message.lower()

    @pytest.mark.asyncio
    async def test_handles_malformed_actions(self, action_executor, mock_assistant_state):
        """Test handling of malformed action data."""

        malformed_actions = [
            {"type": "move"},  # Missing target
            {"target": {"x": 10, "y": 5}},  # Missing type
            {"type": "interact", "target": "lamp_001"},  # Missing parameters
            None,  # Null action
        ]

        with patch.object(assistant_service, 'get_assistant_state', return_value=mock_assistant_state):

            for action in malformed_actions:
                result = await action_executor.execute_action(action)
                assert result.success is False
                assert "invalid" in result.message.lower() or "malformed" in result.message.lower()

    @pytest.mark.asyncio
    async def test_action_timeout_handling(self, action_executor, mock_assistant_state):
        """Test handling of action timeouts."""

        move_action = {
            "type": "move",
            "target": {"x": 20, "y": 10},
            "parameters": {"reason": "Testing timeout", "timeout": 0.1}
        }

        # Mock a slow operation
        with patch.object(assistant_service, 'get_assistant_state', return_value=mock_assistant_state), \
             patch.object(pathfinding_service, 'find_path', side_effect=lambda *args: [{"x": 20, "y": 10}]), \
             patch('asyncio.sleep', side_effect=lambda x: None):  # Speed up for testing

            result = await action_executor.execute_action(move_action)

            # Should handle timeouts gracefully
            assert isinstance(result, ActionResult)
            assert result.action_type == "move"


class TestActionExecutorPerformance:
    """Test performance aspects of action execution."""

    @pytest.mark.asyncio
    async def test_action_execution_performance(self, action_executor, mock_assistant_state, mock_room_objects):
        """Test that actions execute within reasonable time limits."""

        import time

        simple_action = {
            "type": "state_change",
            "target": "assistant",
            "parameters": {"mood": "happy", "reason": "Performance test"}
        }

        with patch.object(assistant_service, 'get_assistant_state', return_value=mock_assistant_state), \
             patch.object(assistant_service, 'set_assistant_mood'):

            start_time = time.time()
            result = await action_executor.execute_action(simple_action)
            execution_time = time.time() - start_time

            assert result.success is True
            assert execution_time < 1.0  # Should execute in less than 1 second

    @pytest.mark.asyncio
    async def test_concurrent_action_execution(self, action_executor, mock_assistant_state):
        """Test concurrent execution of multiple actions."""

        actions = [
            {
                "type": "state_change",
                "target": "assistant",
                "parameters": {"mood": "happy", "reason": "Concurrent test 1"}
            },
            {
                "type": "state_change",
                "target": "assistant",
                "parameters": {"expression": "smile.png", "reason": "Concurrent test 2"}
            }
        ]

        with patch.object(assistant_service, 'get_assistant_state', return_value=mock_assistant_state), \
             patch.object(assistant_service, 'set_assistant_mood'), \
             patch.object(assistant_service, 'set_assistant_expression'):

            results = await action_executor.execute_actions_concurrently(actions)

            assert len(results) == 2
            assert all(result.success for result in results)